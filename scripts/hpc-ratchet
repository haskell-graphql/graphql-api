#!/usr/bin/python
"""Ensure our test coverage only increases.

Easier than figuring out how to get hpc-coveralls to work with Stack.
"""

from pprint import pprint
import re
import subprocess


EXPRESSIONS = 'expressions'
BOOLEANS = 'booleans'
ALTERNATIVES = 'alternatives'
LOCAL_DECLS = 'local_decls'
TOP_LEVEL_DECLS = 'top_level_decls'


def get_report_summary():
    """Run ``stack hpc report --all`` and return the output.

    Assumes that ``stack test --coverage`` has already been run.
    """
    process = subprocess.Popen(["stack", "hpc", "report", "--all"], stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    return stderr


"""Parse a line from the summary.

Takes a line like:
    NN% thingy wotsit used (YYYY/ZZZZ)

And turns it into:
    ("thingy wotsit used", "YYYY", "ZZZZ")
"""
_summary_line_re = re.compile(r'^\d\d% ([a-z -]+) \((\d+)/(\d+)\)$')


"""Map from the human-readable descriptions to keys in the summary dict."""
_summary_line_entries = {
    'expressions used': EXPRESSIONS,
    'boolean coverage': BOOLEANS,
    'alternatives used': ALTERNATIVES,
    'local declarations used': LOCAL_DECLS,
    'top-level declarations used': TOP_LEVEL_DECLS,
}

def parse_summary_line(summary_line):
    """Parse a line in the summary that indicates coverage we want to ratchet.

    Turns::

        NN% thingy wotsit used (YYYY/ZZZZ)

    Into::

        ('thingy', YYYY, ZZZZ)

    Returns ``None`` if the line doesn't match the pattern.
    """
    match = _summary_line_re.match(summary_line.strip())
    if match is None:
        return
    description, covered, total = match.groups()
    try:
        key = _summary_line_entries[description]  # XXX: Explodes if output changes.
    except KeyError:
        return
    return key, int(covered), int(total)


def parse_report_summary(summary):
    """Parse the output of ``stack hpc report --all``.

    Turns this::

        Getting project config file from STACK_YAML environment
        Generating combined report
         57% expressions used (2172/3801)
         47% boolean coverage (9/19)
              38% guards (5/13), 4 always True, 4 unevaluated
              75% 'if' conditions (3/4), 1 unevaluated
              50% qualifiers (1/2), 1 always True
         45% alternatives used (156/344)
         81% local declarations used (70/86)
         33% top-level declarations used (348/1052)
        The combined report is available at /path/hpc_index.html

    Into this::

        {'expressions': (2172, 3801),
         'booleans': (9, 19),
         'alternatives': (156, 344),
         'local_decls': (70, 86),
         'top_level_decls': (348, 1052),
        }
    """
    report = {}
    for line in summary.splitlines():
        parsed = parse_summary_line(line)
        if not parsed:
            continue
        key, covered, total = parsed
        report[key] = (covered, total)
    return report


def main():
    report = parse_report_summary(get_report_summary())
    pprint(report)


main()
